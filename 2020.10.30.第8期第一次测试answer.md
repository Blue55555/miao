x _ x _ x _ x _ x
x % 2 == 1
x % 2 == 0
x > 200
x % 400 == 0 || x % 4 == 0 && x % 100 != 0
x == 2 || x == 3 || (x - 4) % 2 != 0 && (x - 6) % 3 != 0 && (x - 10) % 5 != 0 && (x - 7) % 14 != 0
x > 50 && x < 100

有一个未知数 x，写出表达以下结果的表达式：

x 的 5 次方。
x 是否为奇数。
x 是否为偶数。
x 是否大于 200。
x 是否是闰年。
x 是否是 100 以内的素数。
x 是否在 50 到 100 以内。

# 浮点数的表示

- 浮点数一般使用 8 字节即 64bit 存储，为双精度浮点数
  - 也有用 4 字节即 32bit 存储的单精度浮点数
- 最左边一位表示符号，0 表示正，1 表示负
- 接下来的 11bit 表示指数
- 剩余的表示科学记数法中的小数部分，不含整数部分，因为整数部分总是 1

- 为什么指数的范围是-1023 到 1024 而非-1024 到 1023？
  - 指数部分并没有使用补码进行存储
  - 正 1024 次方表示无穷大
- 为什么指数部分读出时要减 1023，写入时要加 1023？
  - 指数部分使用原码，范围是 0 到 2047
  - 表示-1023 到 1024
  - 所以 0 表示-1023
  - 所以读出时减，写入时加
- 为什么指数不用补码？
  - 为了能够从左往右扫描即可确定两个浮点数的大小
  - 即除符号位以外只看指数部分即可以确定大小
    - 即指数部分谁先出现 1 谁更大
    - 如果指数部分完全相同，那么底数部分谁先出现 1 谁更大
- 为什么要如此在意浮点大小对比的效率？
  - 因为浮点数更多时候是对比大小而非对比相等
    - 因为浮点数表示的不精确
      - 很难保证数学上相等的两个计算路径在程序中的计算结果也是完全相同的
        - 在程序中 a _ b / c 的结果跟 a / c _ b 有可能不相同的
        - 所以在程序中很少判断两个浮点数的相等
          - 而是判断它们在数轴上的距离，即求其差的绝对值看是否小于某个精度
            - Math.abs(a - b) < Number.EPLSION
- 为什么不把底数的整数部分存储？
  - 因为底数的整数部分总是 1
  - 效果就是二进制状态下的有效位数是 53 位
- 正因为有效位数有 53 位，如果用这 53 位全部分表示整数
  - 即 2 的 53 次方，可以保证在这个范围内的整数运算的精确
  - 所以有一个常量 Number.MAX_SAFE_INTEGER 的值即为 2 的 53 减 1
  - 大于这个范围的数不是不能表示，只是不保证完全精确
    - 大于这个范围无法表示浮点数，且整数也不是连续表示的
- 因为总的有效数字只有 53 位
  - 所以如果整数部分使用的越多，小数部分就越小，反之亦然
  - 而数值越大，整数部分需要的有效位数就越多，而小数部分的有效位数就越少
    - 即数值越大，小数部分的精度就越低
  - 而数值越小，整数部分需要的有效位数就越少，而小数部分的有效位数就越多
    - 即数值越小，小数部分的精度就越高
- IEEE754
  - 单精度浮点数 float float32 f32
    - 使用 4 字节表示，其指数部分 8bit，底数 23bit
  - 双精度浮点数 double float64 f64
    - 使用 8 字节表示，指数部分 11bit，底数 52bit
